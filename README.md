# Software Engineering Group Project Reflection
## Project Summary 
The final project in my Software Engineering II course at Oregon State University required students to work in teams using a continuous integration workflow. As this was an online course, my team members and I were in different time zones and had to navigate collaborating remotely.  We were tasked with writing three conversion functions: converting an integer value to a hexadecimal value, converting a string to a base 10 number, and converting the integer number of seconds since January 1st, 1970 to a string MM-DD-YYYY format.  This course focused primarily on testing and test driven design so we developed unit tests for the project specifications first. Code reviews were mandatory before merging pull requests. My reflection on what it was like to work in team on this project is posted below.
## Previous Experience Developing in Teams
Prior to this course, I had not explicitly been part of a programming team.  When I was working on my geophysics masters, I had coding portions of my project which I worked on individually and then submitted for periodic reviews by my advisor. In this setting, coding was a means to analyzing seismic data and not necessarily the end product.  I had a good deal of flexibility in the methods I chose and the deadlines I set as long I produced publishable results.  However, a drawback to working primarily alone was not having peers to exchange ideas with or push my thinking.  In the CS postbacc program, the intro to programming courses had team reflection assignments.  The programming was completed individually, but we reviewed  our solutions as a group and discussed strengths and possible revisions. Coming from a teacher background, I found it fascinating to see all the variations in solutions to the same coding prompt.  Since these intro courses were my first introduction to python, I learned a lot about python style from my teammates particularly with list comprehensions.  

The main learning curve I encountered with these group assignments was coordinating everyone’s schedule in a remote setting.  Many times, we were working in different time zones with busy schedules and different expectations about how much time should be spent on the assignment.  Despite a few late nights scrabbling to add a last-minute team member’s feedback, this was a good exercise in learning how to work in remote team setting.  I learned direct communication about our deadlines, work preferences, and availability made all the difference in minimizing group frustrations.  I think most of us at some point in our lives experienced the stereotypical negative group project experience.  Although not coding related, I have been on a team where a member does not submit work or at the last minute, tries to add incorrect work and there is a panic to correct and rewrite.  This negative narrative tends to pop up when I see a group assignment in a course but working with people is a part of the real world. This might be the high school teacher in me talking, but I think most people want to do a good job and want to submit quality work.  I have learned if there is frustration in the group dynamic, it is better to address it early on and frame the conversation as more “what do you need and how can I help?” as opposed to “I’m done my part of the project, why aren’t you done yours?”  When I saw there was a group project in this class, I was excited to use git and work with a shared repository. Developers work on teams and here was a chance for me to see what it was like!  I was also nervous about the unknown.  I took Software Engineering II out of sequence to fit my schedule and I did not know anyone in this class.  I was worried everyone would already have a team and I would be the “odd coder out”.  As it turns out, there were plenty of great classmates looking for team members.

## Working with Continuous Integration
This was my first time using a Continuous Integration workflow.  My initial reservations centered around the amount of communication and teamwork needed to keep track of commits and pull requests.  I was not sure how it would work to have three people all working in the same files.  I was most nervous about resolving merge conflicts and using git with the command line.  The A1 assignment gave a preview of what using git from the terminal looked like and how merge conflicts occurred but I had not put it all into practice yet.  Opening a pull request and requiring a code review every time a change was pushed to main seemed a little intimidating at first.  At the start of the project my questions were: Would team members respond to pull requests fast enough?  How would teammates respond if I made mistakes in my code?  How will a team member respond if I ask them to make changes?  My plan to overcome these reservations was to have a solid communication policy with my team and to make sure I was open to a new process.  

Before the project started, my team met with each other to discuss work preferences.   We set up a weekly meeting time and checked in with one another frequently on Teams. This helped resolve most of the group project fears.  Daily commits were an area we all had to work on. Our approach to the project was to have each team member take the lead on one of the three functions and then help trouble shoot and write tests as needed for the other two functions.  Given our work schedules, we were not necessarily working on our function every day, but we did make a point to tell each other what day we would be working and when to look out for new commits.  After tackling the first pull request and merge conflict, I felt much more confident moving forward.  Each member on my team brought different strengths to the table.  One team member was fantastic at organizing meetings, setting internal deadlines, and keeping us all on track.  Another team member was great at setting up random testing.  I think I was strong in trouble shooting build errors and keeping the project cohesive through merges.  Throughout the code review process, I worked on finding the balance between constructive feedback and positive support.  

At first, I was unsure if pointing out something to fix or improve would be interpreted as nitpicking.  Then, on the first pull request I reviewed, I missed that the file name was accidentally called tasks.py instead of task.py.  After approving it, I had to open a new pull request to fix it and then another team member had to review it.  Right then and there, I decided it was much better to take my time with reviews and be thorough rather than deal with the aftermath of pushing incorrect code to the main branch.  Lesson learned!  I think I found more of my voice as a developer during this project.  I became much more comfortable speaking up about changes and making suggestions.  Knowing that someone was going to be looking at my code also pushed me to review my work before submitting a pull request.  I certainly did not want to be the team member slowing down the group!  When I was conducting the code review, I tried to keep the tone positive and observational.  After all, we were all working toward the same goal.

While writing additional random tests, I caught a math error in my function that had been missed during the review.  The moral of the story seemed to be good code reviews save time later.  I tried to be a collaborative team member and jump in wherever needed.  When I finished my function, I was writing tests and helping troubleshoot the other two functions.  All three of our functions were at some point stalled by the complexity error during the build.  I helped my team members reorganize and rethink their functions to pass this error.  I really enjoyed getting the chance to be creative.  Nested if statements seemed to be triggering the complexity error in the my_datetime function and I took advantage of python’s dictionaries to restructure the if statements and simplify the function.  A team member accidently used the prohibitive int() and float() functions in conv_num so I wrote helper functions which handled these conversions while still preserving most of the original working solution.  I think I grew as a mentor because I realized that my job was not to take over or completely rewrite an incorrect portion of code.  I learned to ask  questions, offer suggestions, and be patient as we all learn.         

## Lesson for the Future
Continuous Integrations helps developers work together more effectively and reduces the amount of incorrect code or non-working code that makes it into the final product.  Having the protected main branch with a mandatory code review slows down hasty changes and requires team members to examine any merge conflicts.  This keeps their part of the project up to date with the rest of the group.  If working alone and not checking in with the team, a developer risks creating code that is potentially outdated or difficult to incorporate.  Outdated code may have more merge conflicts. Moreover, a developer that has not been keeping pace with the team may not make the best decisions on which version to keep.  The mandatory Code Reviews provide another layer of protection and ensure an extra pair of eyes examines changes.  They also help developers learn from one another.  The reviewee learns to receive feedback with a positive mindset and becomes a stronger coder for incorporating the suggestions and considering a different approach.  Knowing that someone will be reviewing your work incorporates a level of accountability.  I spent a little extra time reviewing and editing my own work before submitting a pull request. 

In turn, the reviewer not only practices reading and understanding someone else’s code but also how to communicate changes and provide useful feedback.  Having my code reviewed helped me become a stronger reviewer because I had a better idea of how I wanted to receive feedback.  Every time a pull request was made, I loved seeing that green check mark saying the build passed!  The testing suite became a guide to troubleshooting changes and making sure merges were successful.  With multiple people working on a shared code repository, it is easy for a change to accidentally throw off the functionality of other parts of the code.  The red x on the workflow was like a stop sign to pause and troubleshoot before proceeding.  The more robust the test suite, the more developers can be confident that the code is doing what it is supposed to be doing and the changes are appropriate.  For our project, most times a failed unit test would flag an issue with a function that we could repair before the merge.  However, one time I discovered an issue with a unit test that was causing an otherwise successful build to fail.  Having a suite of thoughtful and thorough unit tests saves time in the long run and provides another defensive layer against broken code. 


